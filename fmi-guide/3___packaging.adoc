== Packaging and Code Generation/Loading

=== ZIP Archive Structure

==== Pathnames and Prefixes

Exporting implementations should ensure that the generated FMU ZIP archives are compliant to the ZIP specification.
This implies that only the forward slash `/` shall be used as a path separator, and that path specifications like `.` or `..` do not have specific interpretations, like current directory, etc.

More specifically the ZIP archive should only contain entries with no leading prefix, i.e. the entries should be `modelDescription.xml`, `binaries/x86_64-windows/myfmu.dll`, etc., and not `./modelDescription.xml`, or `myfmu/binaries/x86_64-windows/myfmu.dll`.

To enable interopartion with not-quite conforming implementations, importing implementations should be prepared to support the extraction of FMU ZIP archives with leading `./` prefixes on entries in the archive.
Similarly, implementations should be prepared to support extraction of FMU ZIP archives that use "\" as the path separator.

==== Access to FMU package content

The exporting implementation should not rely on the importing implementation completely unpacking the FMU in one location, since only access to the resources folder is actually specified in the standard.

Obviously some of the fallbacks (discussed in section 3.8 and 5.1) for locating the resources folder relative to the executing DLL/shared object rely on the structure being completely recreated, but those fallbacks are by their nature non-portable fallback mechanisms which only come into play when other, standard conforming mechanisms are not available.

When possible, implementations should unpack the complete ZIP archive content in one location since some FMUs depend on this even if the standard only specifies access to the resources folder.

=== Documentation and Additional Resources

==== Icons

Implementations should support using supplied icon information in the FMU when displaying the FMU in a graphical notation or user interface.

For FMI 3.0, icon information is available as part of the ports and icons information contained in the `icons/terminalsAndIcons.xml` file of the FMU.
This optionally includes detailed icon information for individual ports, as well as global icon information.

For prior versions of FMI, only a model.png file in PNG format in the root of the ZIP archive is available.

Exporting implementations should, at a minimum, generate an informative icon for the FMU and package this in the ZIP archive in the way documented in the FMI standards.
Whenever possible, more detailed information should be provided using the ports and icons information.

==== Documentation

The documentation folder of FMUs provides a specific way to ensure that important documentation needed to use FMUs effectively always travel with the FMU.
Implementations should therefore allow easy access to any documentation supplied in the FMU.

Exporting implementations should allow the user to easily author/add documentation for the FMU.

Exporting implementations should also include any additional documentation needed to effectively run the FMU in the documentation:

- Implementations that produce FMUs that are not considered stand-alone, i.e. specifying `needsExecutionTool=true` in their model description, should provide sufficient information inside the documentation that the recipient of the FMU will know what tools, licenses, and other dependencies are needed to run the FMU.
- Implementations that produce FMUs that require runtime licenses should provide information on what kind of license is needed and how to provide that license so the FMU can use it.

=== Support for 32&64bit Variants of Platforms

Common platforms in use today are available in 32bit and 64bit variants, for example Windows or Linux on Intel processors, or Linux ARM processors.

While those variants are usually closely related, and 64bit variants commonly support running 32bit and 64bit binaries side-by-side, this support is limited:
Most platforms do not support running 32bit and 64bit inside one process image, but only in separate processes.

Since FMI is designed around the ability to run FMUs inside the host implementation process image for efficiency, this means that 32bit and 64bit variants of the same platform are usually not directly compatible.

For this reason exporting implementations should ideally generate FMUs that contain both 32bit and 64bit variants of the binaries, allowing importers to select an appropriate binary.

Since not all exporting implementations can generate both variants easily, importing implementations should consider providing the ability to bridge between 32bit and 64bit implementations, using either inter-process communication or system provided facilities where possible.

Going forward this is likely to be less of a problem on desktop systems, which are migrating to 64bit only implementation spaces, but for mobile or embedded platforms this issue is likely to be pertinent for some time.

=== Support for Multiple Platforms

FMU exporting implementations should strive to support common platforms out of the box, and should provide support for generating FMUs that contain multiple binary implementations, and where feasible a source code implementation, in one go.

=== Compiler Dependencies

Exporting implementations should document supported compilers, their versions, and required compiler flags and settings in order to compile generated source FMUs for common platforms.

For FMI 3.0, the compilers and required compiler flags and settings should be placed in the `buildDescription.xml` file of the FMU, to allow automated building from source as far as possible. 

When generating binary FMUs directly, the supported/used compilers, compiler flags and settings should also be documented, in order to allow users to troubleshoot integration issues when integrating binary FMUs into other environments.

Where possible the use of user supplied compilers and compiler flags and settings should be supported in order to automate generation of binary FMUs for non-common targets or to support user-specific requirements in the binary FMU compilation/linking stage.

=== Handling of FMU namespaces

==== FMU Importing Implementations

Importing implementations should correctly handle the import of multiple 1.0 FMUs with identical model identifiers. In the case of FMUs with dynamic library implementations this is supported by most platforms since symbol lookup can be performed scoped to one dynamic library namespace (see e.g. dlsym/GetProcAddr functions for Linux/Windows). Starting with 2.0 FMUs with dynamic library implementations will always use identical symbols for the entry points in any case, so that this has to be supported correctly.

For source code or static library implementations the problem of conflicting model identifiers can usually only be solved through compilation/linking to corresponding separate dynamic libraries or other similar mechanisms to deal with the relevant scoping issues.

=== Handling of Code Dependencies

==== FMU Importing Implementations

Importing implementations should consider changing the working directory of the process to the relevant binary subdirectory of the unpacked FMU when loading the FMU DLL/SO to allow unsophisticated exporting implementations to load dependent DLLs/SOs relative to this directory. It is of course the responsibility of the FMU DLL/SO to implement proper dependent DLL/SO loading regardless of the current working directory of the process, however in practice a number of current or former implementations did not correctly implement this and can thus fail to load when the current directory is not the directory that contains the FMU DLL/SO.

==== FMU Exporting Implementations

Exporting implementations should ideally avoid reliance on additional dynamic libraries, i.e. generated dynamic libraries should ideally be stand-alone. Where that is not feasible, implementations should prefer to use manual dynamic loading of dependent libraries at runtime (e.g. using dlopen/LoadLibrary), where the load path of the libraries is based on the resources URI provided, or should use DLL-relative path derivation either of the DLL folder or of the resources folder when the resources URI is not available (FMI 1.0 ME) or not valid.

Relying on pre-linking, where the dynamic loading of the dependent libraries is automatically handled by the platform dynamic linker/loader is not likely to work in all cases (e.g. on Windows the searched paths will be based on the simulator executable, not the FMU DLL), and is unlikely to provide user-understandable error messages in case of failure.

Note that simple calls to LoadLibrary/LoadLibraryEx on Windows, without specifying the full path to the library are also not going to work in general, for the same reasons: The search path is going to be based on the location of the simulator executable and not the FMU DLL.
